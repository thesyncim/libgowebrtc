# libgowebrtc Project Guidelines

## Definition of Done

A task is only complete when ALL of the following are true:

### Code Quality
- [ ] Code compiles without errors: `go build ./...`
- [ ] Linter passes: `golangci-lint run ./...`
- [ ] No stub implementations (functions that return nil/false without real logic)
- [ ] No TODO comments left in new code
- [ ] Public APIs have doc comments

### Testing Requirements

**DO write tests that:**
- Call real functions and verify actual behavior
- Test error conditions with actual error paths
- Test edge cases (empty input, max values, nil pointers)
- Use real encode/decode roundtrips for codec tests
- Use LibPeerPair or PeerPair for connection tests
- Measure actual frame sizes, packet counts, timestamps
- Verify decoded output dimensions/samples

**DO NOT write tests that:**
- Only check struct field assignment (useless - compiler already checks this)
- Only do compile-time interface checks (`var _ Interface = (*Type)(nil)`)
- Check if `err != nil` without testing actual error conditions
- Create objects but never use them
- Just call a function and discard the result

### Test Examples

**BAD - Trivial/Useless:**
```go
// BAD: Just struct assignment
func TestConfig(t *testing.T) {
    cfg := Config{Width: 1920, Height: 1080}
    if cfg.Width != 1920 { t.Error("...") }  // Obviously passes
}

// BAD: Compile-time check only
func TestInterface(t *testing.T) {
    var _ Encoder = (*encoder)(nil)  // Compiler already catches this
}

// BAD: Creates object, does nothing
func TestCreate(t *testing.T) {
    enc, _ := NewEncoder(config)
    _ = enc  // Never used
}
```

**GOOD - Real behavior tests:**
```go
// GOOD: Tests actual encoding roundtrip
func TestVideoRoundtrip(t *testing.T) {
    enc, _ := encoder.NewH264Encoder(config)
    defer enc.Close()
    dec, _ := decoder.NewVideoDecoder(codec.H264)
    defer dec.Close()

    srcFrame := frame.NewI420Frame(640, 480)
    fillTestPattern(srcFrame)

    encBuf := make([]byte, enc.MaxEncodedSize())
    result, err := enc.EncodeInto(srcFrame, encBuf, true)
    if err != nil { t.Fatal(err) }
    if result.N == 0 { t.Fatal("encoded size is 0") }
    if !result.IsKeyframe { t.Error("first frame should be keyframe") }

    dstFrame := frame.NewI420Frame(640, 480)
    err = dec.DecodeInto(encBuf[:result.N], dstFrame, 0, true)
    if err != nil { t.Fatal(err) }
    if dstFrame.Width != 640 { t.Error("decoded width mismatch") }
}

// GOOD: Tests error condition
func TestEncoderClosed(t *testing.T) {
    enc, _ := encoder.NewVP8Encoder(config)
    enc.Close()
    _, err := enc.EncodeInto(frame, buf, false)
    if err != ErrEncoderClosed { t.Errorf("want ErrEncoderClosed, got %v", err) }
}

// GOOD: Tests connection flow
func TestOfferAnswer(t *testing.T) {
    pp := NewLibPeerPair(t)
    defer pp.Close()

    track, _ := pp.Sender.CreateVideoTrack("video", codec.VP8, 640, 480)
    pp.Sender.AddTrack(track, "stream-0")

    err := pp.ExchangeOfferAnswer()
    if err != nil { t.Fatal(err) }

    // Verify SDP contains video
    if !strings.Contains(pp.Sender.LocalDescription().SDP, "m=video") {
        t.Error("SDP should contain video m-line")
    }
}
```

## Project Structure

```
libgowebrtc/
├── shim/                    # C++ FFI shim for libwebrtc
│   ├── shim.h              # Public C API
│   └── shim.cc             # Implementation
├── internal/ffi/           # Go FFI bindings (purego, no CGO)
├── pkg/
│   ├── codec/              # Codec types and configs
│   ├── encoder/            # Video/audio encoders
│   ├── decoder/            # Video/audio decoders
│   ├── frame/              # Video/audio frame types
│   ├── packetizer/         # RTP packetization
│   ├── depacketizer/       # RTP depacketization
│   ├── pc/                 # PeerConnection wrapper
│   ├── track/              # Local tracks (Pion-compatible)
│   └── media/              # MediaStream API
├── test/
│   ├── e2e/                # Headless e2e tests (libwebrtc only)
│   └── interop/            # Pion interop tests
└── examples/
```

## Running Tests

```bash
# Unit tests (no shim required)
go test ./...

# With shim library (real encoding/decoding)
LIBWEBRTC_SHIM_PATH=./lib/darwin_arm64/libwebrtc_shim.dylib go test ./...

# Specific package
go test ./pkg/encoder/...

# With verbose output
go test -v ./...

# Benchmarks
go test -bench=. ./...
```

## Common Patterns

### Track Writing (pkg/pc)
```go
pc, _ := pc.NewPeerConnection(config)
track, _ := pc.CreateVideoTrack("video", codec.VP8, 640, 480)
pc.AddTrack(track, "stream-0")

// Write frames
frame := frame.NewI420Frame(640, 480)
track.WriteVideoFrame(frame)
```

### Pion Integration (pkg/track)
```go
// Create libwebrtc-backed track compatible with Pion
vt, _ := track.NewVideoTrack(track.VideoTrackConfig{
    ID: "video", StreamID: "stream",
    Codec: codec.VP8, Width: 640, Height: 480,
})

// Add to Pion PeerConnection
pionPC.AddTrack(vt)  // Works because VideoTrack implements webrtc.TrackLocal
```

### Encode/Decode Roundtrip
```go
enc, _ := encoder.NewH264Encoder(codec.H264Config{Width: 640, Height: 480, ...})
defer enc.Close()

dec, _ := decoder.NewVideoDecoder(codec.H264)
defer dec.Close()

// Encode
result, _ := enc.EncodeInto(srcFrame, encBuf, forceKeyframe)

// Decode
dec.DecodeInto(encBuf[:result.N], dstFrame, timestamp, isKeyframe)
```

## What's Currently Working

- H264/VP8/VP9/AV1 video encoding/decoding via FFI
- Opus audio encoding/decoding via FFI
- Allocation-free encode/decode with reusable buffers
- Runtime bitrate/framerate control
- Keyframe request
- PeerConnection with offer/answer
- Track writing with frame push to native source
- Pion interop (libwebrtc tracks work with Pion PC)
- DataChannel communication
- Frame receiving from remote tracks (SetOnVideoFrame/SetOnAudioFrame)

## Remaining Work

### Device Capture Gap (FFI ready, pkg/media not wired)
The FFI layer for device capture is complete (`internal/ffi/device.go`):
- `ffi.EnumerateDevices()` - lists cameras/mics
- `ffi.NewVideoCapture(deviceID, w, h, fps)` - camera capture
- `ffi.NewAudioCapture(deviceID, sampleRate, channels)` - mic capture
- `ffi.EnumerateScreens()` - lists screens/windows
- `ffi.NewScreenCapture(id, isWindow, fps)` - screen capture

**TODO**: Wire these into `pkg/media/media.go`:
```go
// In GetUserMedia:
if constraints.Video != nil {
    capture, _ := ffi.NewVideoCapture(deviceID, w, h, fps)
    capture.Start(func(frame *ffi.CapturedVideoFrame) {
        track.WriteFrame(frame)  // Push to track
    })
}
```

### Stubs (Not Yet Implemented)
- `PeerConnection.GetStats()` - returns empty map (needs shim function)
- `RTPSender.SetParameters()` / `GetParameters()` - stubs (needs shim)
- `RTPTransceiver.SetDirection()` / `Stop()` - stubs (needs shim)
- `PeerConnection.AddTransceiver()` - partial implementation (needs shim)
