//go:build ignore

// Code generator for FFI bindings.
// Generates func_vars.go, func_bind_purego.go, and func_bind_cgo.go
// from funcs.json function definitions.
//
// Usage: go run ./gen
package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

type Param struct {
	Name string `json:"name"`
	Type string `json:"type"`
}

type Function struct {
	GoName   string  `json:"go_name"`
	CName    string  `json:"c_name"`
	Params   []Param `json:"params"`
	Return   string  `json:"return"`
	Category string  `json:"category"`
}

type FuncDefs struct {
	Functions []Function `json:"functions"`
}

func main() {
	// Read function definitions
	data, err := os.ReadFile("funcs.json")
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading funcs.json: %v\n", err)
		os.Exit(1)
	}

	var defs FuncDefs
	if err := json.Unmarshal(data, &defs); err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing funcs.json: %v\n", err)
		os.Exit(1)
	}

	outDir := ".."

	// Generate all files
	if err := generateFuncVars(defs, outDir); err != nil {
		fmt.Fprintf(os.Stderr, "Error generating func_vars.go: %v\n", err)
		os.Exit(1)
	}

	if err := generatePuregoBind(defs, outDir); err != nil {
		fmt.Fprintf(os.Stderr, "Error generating func_bind_purego.go: %v\n", err)
		os.Exit(1)
	}

	if err := generateCGOBind(defs, outDir); err != nil {
		fmt.Fprintf(os.Stderr, "Error generating func_bind_cgo.go: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Generated %d function bindings\n", len(defs.Functions))
}

// generateFuncVars generates the shared function variable declarations
func generateFuncVars(defs FuncDefs, outDir string) error {
	var buf bytes.Buffer

	buf.WriteString(`// Code generated by go generate; DO NOT EDIT.

package ffi

// Function pointers - populated by registerFunctions()
// NOTE: All int/uint types are explicitly sized to match C ABI
var (
`)

	// Group by category
	categories := groupByCategory(defs.Functions)
	for _, cat := range sortedCategories(categories) {
		buf.WriteString(fmt.Sprintf("\t// %s\n", cat))
		for _, fn := range categories[cat] {
			buf.WriteString(fmt.Sprintf("\t%s %s\n", fn.GoName, goFuncType(fn)))
		}
		buf.WriteString("\n")
	}

	buf.WriteString(")\n")

	return writeGoFile(filepath.Join(outDir, "func_vars.go"), buf.Bytes())
}

// generatePuregoBind generates the purego-based function binding
func generatePuregoBind(defs FuncDefs, outDir string) error {
	var buf bytes.Buffer

	buf.WriteString(`// Code generated by go generate; DO NOT EDIT.

//go:build !ffigo_cgo

package ffi

import "github.com/ebitengine/purego"

func registerFunctions() error {
`)

	// Group by category
	categories := groupByCategory(defs.Functions)
	for _, cat := range sortedCategories(categories) {
		buf.WriteString(fmt.Sprintf("\t// %s\n", cat))
		for _, fn := range categories[cat] {
			buf.WriteString(fmt.Sprintf("\tregisterLibFunc(&%s, libHandle, %q)\n", fn.GoName, fn.CName))
		}
		buf.WriteString("\n")
	}

	buf.WriteString(`	return nil
}

func registerLibFunc(fptr any, handle uintptr, name string) {
	sym, err := dlsymLibrary(handle, name)
	if err != nil {
		panic(err)
	}
	purego.RegisterFunc(fptr, sym)
}
`)

	return writeGoFile(filepath.Join(outDir, "func_bind_purego.go"), buf.Bytes())
}

// generateCGOBind generates the CGO-based function binding
func generateCGOBind(defs FuncDefs, outDir string) error {
	var buf bytes.Buffer

	// CGO preamble
	buf.WriteString(`// Code generated by go generate; DO NOT EDIT.

//go:build ffigo_cgo

package ffi

/*
#include <stdint.h>

// Function pointer storage
`)

	// Generate function pointer storage
	for _, fn := range defs.Functions {
		buf.WriteString(fmt.Sprintf("static void* fn_%s;\n", fn.CName))
	}

	buf.WriteString("\n// Setters (called from Go after dlsym)\n")

	// Generate setter functions
	for _, fn := range defs.Functions {
		buf.WriteString(fmt.Sprintf("void set_fn_%s(void* fn) { fn_%s = fn; }\n", fn.CName, fn.CName))
	}

	buf.WriteString("\n// Trampoline functions\n")

	// Generate trampoline functions
	for _, fn := range defs.Functions {
		buf.WriteString(cTrampoline(fn))
	}

	buf.WriteString(`*/
import "C"
import "unsafe"

func registerFunctions() error {
`)

	// Generate setter calls
	categories := groupByCategory(defs.Functions)
	for _, cat := range sortedCategories(categories) {
		buf.WriteString(fmt.Sprintf("\t// %s\n", cat))
		for _, fn := range categories[cat] {
			buf.WriteString(fmt.Sprintf("\tC.set_fn_%s(unsafe.Pointer(mustDlsym(libHandle, %q)))\n", fn.CName, fn.CName))
		}
		buf.WriteString("\n")
	}

	buf.WriteString("\t// Assign Go wrapper functions\n")

	// Generate Go wrapper assignments
	for _, cat := range sortedCategories(categories) {
		buf.WriteString(fmt.Sprintf("\t// %s\n", cat))
		for _, fn := range categories[cat] {
			buf.WriteString(goWrapper(fn))
		}
		buf.WriteString("\n")
	}

	buf.WriteString(`	return nil
}

func mustDlsym(handle uintptr, name string) uintptr {
	sym, err := dlsymLibrary(handle, name)
	if err != nil {
		panic(err)
	}
	return sym
}
`)

	return writeGoFile(filepath.Join(outDir, "func_bind_cgo.go"), buf.Bytes())
}

// goFuncType returns the Go function type signature
func goFuncType(fn Function) string {
	params := make([]string, len(fn.Params))
	for i, p := range fn.Params {
		params[i] = p.Name + " " + p.Type
	}

	ret := ""
	if fn.Return != "void" {
		ret = " " + fn.Return
	}

	return fmt.Sprintf("func(%s)%s", strings.Join(params, ", "), ret)
}

// cType maps Go types to C types
func cType(goType string) string {
	switch goType {
	case "int32":
		return "int32_t"
	case "uint32":
		return "uint32_t"
	case "int64":
		return "int64_t"
	case "uint64":
		return "uint64_t"
	case "int16":
		return "int16_t"
	case "uint16":
		return "uint16_t"
	case "float32":
		return "float"
	case "float64":
		return "double"
	case "uintptr":
		return "uintptr_t"
	default:
		return goType
	}
}

// cgoType maps Go types to CGO C. types
func cgoType(goType string) string {
	switch goType {
	case "int32":
		return "C.int32_t"
	case "uint32":
		return "C.uint32_t"
	case "int64":
		return "C.int64_t"
	case "uint64":
		return "C.uint64_t"
	case "int16":
		return "C.int16_t"
	case "uint16":
		return "C.uint16_t"
	case "float32":
		return "C.float"
	case "float64":
		return "C.double"
	case "uintptr":
		return "C.uintptr_t"
	default:
		return "C." + goType
	}
}

// cTrampoline generates a C trampoline function
func cTrampoline(fn Function) string {
	var buf bytes.Buffer

	// Return type
	retType := "void"
	if fn.Return != "void" {
		retType = cType(fn.Return)
	}

	// Parameter list
	params := make([]string, len(fn.Params))
	for i, p := range fn.Params {
		params[i] = fmt.Sprintf("%s %s", cType(p.Type), p.Name)
	}

	// Function signature
	buf.WriteString(fmt.Sprintf("%s call_%s(%s) {\n", retType, fn.CName, strings.Join(params, ", ")))

	// Typedef for function pointer type
	paramTypes := make([]string, len(fn.Params))
	for i, p := range fn.Params {
		paramTypes[i] = cType(p.Type)
	}
	buf.WriteString(fmt.Sprintf("    typedef %s (*fn_t)(%s);\n", retType, strings.Join(paramTypes, ", ")))

	// Call through function pointer
	argNames := make([]string, len(fn.Params))
	for i, p := range fn.Params {
		argNames[i] = p.Name
	}

	if fn.Return == "void" {
		buf.WriteString(fmt.Sprintf("    ((fn_t)fn_%s)(%s);\n", fn.CName, strings.Join(argNames, ", ")))
	} else {
		buf.WriteString(fmt.Sprintf("    return ((fn_t)fn_%s)(%s);\n", fn.CName, strings.Join(argNames, ", ")))
	}

	buf.WriteString("}\n")
	return buf.String()
}

// goWrapper generates a Go wrapper function assignment
func goWrapper(fn Function) string {
	var buf bytes.Buffer

	// Parameter names for the lambda
	paramNames := make([]string, len(fn.Params))
	paramDecls := make([]string, len(fn.Params))
	cgoArgs := make([]string, len(fn.Params))
	for i, p := range fn.Params {
		paramNames[i] = p.Name
		paramDecls[i] = fmt.Sprintf("%s %s", p.Name, p.Type)
		cgoArgs[i] = fmt.Sprintf("%s(%s)", cgoType(p.Type), p.Name)
	}

	// Generate assignment
	if fn.Return == "void" {
		buf.WriteString(fmt.Sprintf("\t%s = func(%s) {\n", fn.GoName, strings.Join(paramDecls, ", ")))
		buf.WriteString(fmt.Sprintf("\t\tC.call_%s(%s)\n", fn.CName, strings.Join(cgoArgs, ", ")))
		buf.WriteString("\t}\n")
	} else {
		buf.WriteString(fmt.Sprintf("\t%s = func(%s) %s {\n", fn.GoName, strings.Join(paramDecls, ", "), fn.Return))
		buf.WriteString(fmt.Sprintf("\t\treturn %s(C.call_%s(%s))\n", fn.Return, fn.CName, strings.Join(cgoArgs, ", ")))
		buf.WriteString("\t}\n")
	}

	return buf.String()
}

// groupByCategory groups functions by their category
func groupByCategory(funcs []Function) map[string][]Function {
	result := make(map[string][]Function)
	for _, fn := range funcs {
		result[fn.Category] = append(result[fn.Category], fn)
	}
	return result
}

// sortedCategories returns category names in a deterministic order
func sortedCategories(m map[string][]Function) []string {
	// Define preferred order
	order := []string{
		"VideoEncoder", "VideoDecoder",
		"AudioEncoder", "AudioDecoder",
		"Packetizer", "Depacketizer",
		"Memory", "Version",
		"PeerConnection", "PeerConnectionExtended",
		"RTPSender", "RTPReceiver", "RTPTransceiver",
		"DataChannel",
		"VideoTrackSource", "AudioTrackSource",
		"RemoteTrack",
		"ScalabilityMode", "CodecCapabilities", "RTPSenderCodec",
		"BandwidthEstimation",
		"DeviceCapture", "ScreenCapture", "Permissions",
	}

	// Build result from order, skipping missing categories
	var result []string
	seen := make(map[string]bool)
	for _, cat := range order {
		if _, ok := m[cat]; ok {
			result = append(result, cat)
			seen[cat] = true
		}
	}

	// Add any remaining categories alphabetically
	var remaining []string
	for cat := range m {
		if !seen[cat] {
			remaining = append(remaining, cat)
		}
	}
	sort.Strings(remaining)
	result = append(result, remaining...)

	return result
}

// writeGoFile writes and formats a Go source file
func writeGoFile(path string, content []byte) error {
	formatted, err := format.Source(content)
	if err != nil {
		// Write unformatted for debugging
		if werr := os.WriteFile(path+".err", content, 0644); werr != nil {
			return fmt.Errorf("format error: %v (also failed to write debug file: %v)", err, werr)
		}
		return fmt.Errorf("format error (debug file written to %s.err): %v", path, err)
	}
	return os.WriteFile(path, formatted, 0644)
}
